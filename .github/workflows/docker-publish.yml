name: Publish Docker image

on:
  release:
    types: [published]

# ✅ Moindre privilège — read-only global, surcharge au niveau job
permissions:
  contents: read

# ─────────────────────────────────────────────────────────────────
# STRATÉGIE MULTI-PLATFORM
#
#  Job 1 — scan   : build amd64 uniquement (load:true pour Trivy)
#                   → scan Trivy, SARIF, SBOM
#                   → bloque le job 2 si CRITICAL détectée
#
#  Job 2 — publish : build multi-arch (amd64 + arm64/v8) + push
#                    → provenance SLSA L3, SBOM, signature cosign
#                    → cache GHA chaud (layers déjà buildés par job 1)
#
# Pourquoi 2 jobs ?
#   load:true (requis par Trivy) est incompatible avec multi-platform.
#   On scanne sur amd64 — les vulns sont identiques entre les archs
#   car les couches applicatives (Alpine, Python, APK) sont les mêmes.
# ─────────────────────────────────────────────────────────────────

jobs:

  # ═══════════════════════════════════════════════════════════════
  # JOB 1 — BUILD amd64 + SCAN SÉCURITÉ
  # ═══════════════════════════════════════════════════════════════
  scan:
    name: Build amd64 + Scan sécurité
    runs-on: ubuntu-latest

    permissions:
      contents: read
      security-events: write  # upload-sarif

    env:
      IMAGE_NAME: yabison/docker-ansible
      DOCKERFILE: docker/Dockerfile

    outputs:
      # Transmis au job publish pour éviter de relire le .env
      version:              ${{ steps.version.outputs.version }}
      ALPINE_VERSION:       ${{ steps.dotenv.outputs.ALPINE_VERSION }}
      PYTHON_VERSION:       ${{ steps.dotenv.outputs.PYTHON_VERSION }}
      PASSBOLT_CLI_VERSION: ${{ steps.dotenv.outputs.PASSBOLT_CLI_VERSION }}
      SUPERCRONIC_VERSION:  ${{ steps.dotenv.outputs.SUPERCRONIC_VERSION }}
      DEVOPS_USER:          ${{ steps.dotenv.outputs.DEVOPS_USER }}
      DEVOPS_GROUP:         ${{ steps.dotenv.outputs.DEVOPS_GROUP }}

    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Valider et extraire la version
        id: version
        run: |
          if [[ ! "${GITHUB_REF}" =~ ^refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Tag invalide. Format attendu : vX.Y.Z (ex: v2.1.0)"
            exit 1
          fi
          echo "version=${GITHUB_REF_NAME#v}" >> "${GITHUB_OUTPUT}"
        shell: bash

      - name: Charger les variables depuis .env
        id: dotenv
        run: |
          [ ! -f ".env" ] && echo "::error::.env introuvable" && exit 1
          while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }"            ]] && continue
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
              key="${BASH_REMATCH[1]}"
              val="${BASH_REMATCH[2]%\"}"; val="${val#\"}"; val="${val%\'}"; val="${val#\'}"
              echo "${key}=${val}" >> "${GITHUB_OUTPUT}"
            fi
          done < .env
        shell: bash

      - name: Lint Dockerfile (Hadolint)
        uses: hadolint/hadolint-action@54c9adbab1582c2ef04b2016b760714a4bfde3cf  # v3.1.0
        with:
          dockerfile: ${{ env.DOCKERFILE }}
          failure-threshold: warning

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f  # v3.12.0

      # ✅ Build amd64 uniquement avec load:true → Trivy peut scanner l'image locale
      - name: Build image (amd64 — pour scan Trivy)
        uses: docker/build-push-action@48aba3b46d1b1fec4febb7c5d0c644b249a11355  # v6.10.0
        with:
          context: .
          file: ${{ env.DOCKERFILE }}
          platforms: linux/amd64        # amd64 seulement — load:true incompatible multi-arch
          push: false
          load: true                    # requis pour que Trivy accède à l'image
          tags: ${{ env.IMAGE_NAME }}:scan-${{ github.sha }}
          build-args: |
            VERSION=${{ steps.version.outputs.version }}
            BUILD_DATE=${{ github.event.release.created_at }}
            VCS_REF=${{ github.sha }}
            VCS_URL=https://github.com/${{ github.repository }}
            ALPINE_VERSION=${{ steps.dotenv.outputs.ALPINE_VERSION }}
            PYTHON_VERSION=${{ steps.dotenv.outputs.PYTHON_VERSION }}
            PASSBOLT_CLI_VERSION=${{ steps.dotenv.outputs.PASSBOLT_CLI_VERSION }}
            SUPERCRONIC_VERSION=${{ steps.dotenv.outputs.SUPERCRONIC_VERSION }}
            DEVOPS_USER=${{ steps.dotenv.outputs.DEVOPS_USER }}
            DEVOPS_GROUP=${{ steps.dotenv.outputs.DEVOPS_GROUP }}
            DEVOPS_UID=1000
            DEVOPS_GID=1000
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Scan → SARIF (GitHub Security tab)
        uses: aquasecurity/trivy-action@c1824fd6edce30d7ab345a9989de00bbd46ef284  # v0.34.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:scan-${{ github.sha }}
          format: sarif
          output: trivy-results.sarif
          severity: CRITICAL,HIGH
          scanners: vuln,secret,misconfig
          ignore-unfixed: true
          exit-code: 0   # ← Passer à 1 pour bloquer le push si CRITICAL détectée

      - name: Scan → JSON (artefact)
        uses: aquasecurity/trivy-action@c1824fd6edce30d7ab345a9989de00bbd46ef284  # v0.34.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:scan-${{ github.sha }}
          format: json
          output: trivy-report.json
          severity: CRITICAL,HIGH
          scanners: vuln,secret,misconfig
          ignore-unfixed: true
          exit-code: 0
          skip-setup-trivy: true

      - name: Scan → CycloneDX SBOM
        uses: aquasecurity/trivy-action@c1824fd6edce30d7ab345a9989de00bbd46ef284  # v0.34.0
        with:
          image-ref: ${{ env.IMAGE_NAME }}:scan-${{ github.sha }}
          format: cyclonedx
          output: sbom.cyclonedx.json
          exit-code: 0
          skip-setup-trivy: true

      - name: Upload SARIF → GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@9e907b5e64f6b83e7804b09294d44122997950d6  # v3.28.0
        if: always()
        with:
          sarif_file: trivy-results.sarif

      - name: Upload artefacts sécurité
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08  # v4.6.0
        if: always()
        with:
          name: security-reports-${{ github.ref_name }}
          path: |
            trivy-report.json
            trivy-results.sarif
            sbom.cyclonedx.json
          retention-days: 90


  # ═══════════════════════════════════════════════════════════════
  # JOB 2 — BUILD MULTI-ARCH + PUSH + SIGNATURE
  # Déclenché seulement si le scan est passé (needs: scan)
  # ═══════════════════════════════════════════════════════════════
  publish:
    name: Build multi-arch + Push + Sign
    runs-on: ubuntu-latest
    needs: scan          # ← bloqué tant que le scan n'est pas vert

    permissions:
      contents: read
      packages: write
      id-token: write    # cosign keyless OIDC

    env:
      IMAGE_NAME: yabison/docker-ansible
      DOCKERFILE: docker/Dockerfile

    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Set up QEMU (émulation arm64)
        uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130  # v3.7.0
        with:
          platforms: linux/arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f  # v3.12.0

      - name: Log in to Docker Hub
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9  # v3.7.0
        with:
          username: ${{ vars.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Install cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad  # v4.0.0
      # ✅ Build multi-arch + push en une seule passe
      # Cache GHA chaud (layers amd64 déjà buildés par job scan)
      # → arm64 seul est compilé ici via QEMU
      - name: Build multi-arch + Push
        uses: docker/build-push-action@48aba3b46d1b1fec4febb7c5d0c644b249a11355  # v6.10.0
        id: push
        with:
          context: .
          file: ${{ env.DOCKERFILE }}
          platforms: linux/amd64,linux/arm64/v8
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ github.ref_name }}
            ${{ env.IMAGE_NAME }}:latest
          # ✅ Variables transmises depuis le job scan via outputs
          build-args: |
            VERSION=${{ needs.scan.outputs.version }}
            BUILD_DATE=${{ github.event.release.created_at }}
            VCS_REF=${{ github.sha }}
            VCS_URL=https://github.com/${{ github.repository }}
            ALPINE_VERSION=${{ needs.scan.outputs.ALPINE_VERSION }}
            PYTHON_VERSION=${{ needs.scan.outputs.PYTHON_VERSION }}
            PASSBOLT_CLI_VERSION=${{ needs.scan.outputs.PASSBOLT_CLI_VERSION }}
            SUPERCRONIC_VERSION=${{ needs.scan.outputs.SUPERCRONIC_VERSION }}
            DEVOPS_USER=${{ needs.scan.outputs.DEVOPS_USER }}
            DEVOPS_GROUP=${{ needs.scan.outputs.DEVOPS_GROUP }}
            DEVOPS_UID=1000
            DEVOPS_GID=1000
          provenance: true
          sbom: true
          cache-from: type=gha    # ← layers amd64 déjà chauds depuis job scan
          cache-to: type=gha,mode=max

      # ✅ Signe par digest (immuable) — couvre les deux archs du manifest
      - name: Signer l'image avec cosign (keyless)
        run: |
          cosign sign --yes \
            "${{ env.IMAGE_NAME }}@${{ steps.push.outputs.digest }}"
        env:
          COSIGN_EXPERIMENTAL: "1"

      - name: Récupérer le SBOM depuis les artefacts du job scan
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: security-reports-${{ github.ref_name }}

      - name: Attacher le SBOM à l'image
        run: |
          cosign attach sbom \
            --sbom sbom.cyclonedx.json \
            --type cyclonedx \
            "${{ env.IMAGE_NAME }}@${{ steps.push.outputs.digest }}"
